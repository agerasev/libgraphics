#include <graphics/graphics.hpp>

#pragma once

/**
 * Library for simple graphics
 */

#include "graphics.h"

#include <la/vec.hpp>

namespace gfx {
static const int BLACK   = G_BLACK;
static const int WHITE   = G_WHITE;
static const int RED     = G_RED;
static const int GREEN   = G_GREEN;
static const int BLUE    = G_BLUE;
static const int YELLOW  = G_YELLOW;
static const int CYAN    = G_CYAN;
static const int MAGENTA = G_MAGENTA;

inline int ALPHA(float c) {
	return G_ALPHA(c);
}

class Image {
public:
	int getWidth() const;
	int getHeight() const;
};

class Context;

class Handler {
public:
	Context *super;
	virtual void init() {}
	virtual void dispose() {}
	virtual void draw(double) {}
};

class Shape {
public:
	Shape() = default;
	virtual ~Shape() = default;
	virtual void _draw() const = 0;
};

class Colored {
private:
	float color[4];
	
public:
	Colored() = default;
	virtual ~Colored() = default;
	void setColor(const float c[4]);
	void setColor(const fvec4 &c);
	void setColor(int c);
};

class Quad : public Shape {
public:
	Quad() = default;
	virtual ~Quad() = default;
	virtual void _draw() const override {
		
	}
};

class Circle : public Shape {
public:
	Circle() = default;
	virtual ~Circle() = default;
	virtual void _draw() const override {
		
	}
};

class Ring : public Shape {
public:
	float in = 0.5f;
	
	Ring() = default;
	Ring(float inm) : in(inm) {}
	virtual ~Ring() = default;
	virtual void _draw() const override {
		
	}
};

class Context {
private:
	GContext *context;
	Handler *handler;
	
	bool inited = false;
	void init() {
		inited = true;
		if(handler != nullptr)
			handler->init();
	}
	friend void __gInitCompleted(void *handler);
	
public:
	/* Initializes graphics subsystem */
	Context(Handler *h = nullptr) {
		handler = h;
		handler->super = this;
		__gSetInitHandler(context, static_cast<void *>(this));
		gInit(&context);
	}
	
	/* Safely disposes graphics subsystem */
	virtual ~Context() {
		gDispose(context);
	}
	
	/* Performs resizing of window */
	void resize(int w, int h) {
		gResize(context, w, h);
	}
	
	/* Transform */
	void translate(const float v[2]) {
		gTranslate();
	}

	void transform(const float m[4]);
	
	/* Color */
	void setColor(unsigned color);
	void setColor(const float color[4]);
	
	/* Fill */
	void clear();
	void fill();
	
	/* Geometry */
	void draw(const Shape *s);
	
	Handler *getHandler() {
		return handler;
	}
};


/*
void gDrawCircleSegment(float angle);
void gDrawRingSegment(float in, float angle);
*/

/* Images */
GImage *gGenImage(int width, int height, void *data);
void gFreeImage(GImage *image);
void gDrawImage(GImage *image);

}
